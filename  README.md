# TDD 과제

## 기본 요구 사항
[x] PATCH  `/point/{id}/charge` : 포인트를 충전한다. <br>
[x] PATCH `/point/{id}/use` : 포인트를 사용한다. <br>
[x] GET `/point/{id}` : 포인트를 조회한다. <br>
[x] GET `/point/{id}/histories` : 포인트 내역을 조회한다. <br>
[x] 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다. <br>
[x] 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다. <br>

## 포인트 관리 시스템에서의 동시성 제어

### 개요
- 동일한 사용자의 포인트 충전 및 사용과 같은 트랜잭션을 처리하는데, 
같은 유저에 대해 동시에 여러 요청이 들어올 때 포인트 자원을 공유하기 때문에 동시성 제어가 필요합니다. 
동시성 제어를 통해 특정 사용자에 대한 공유 자원이 각각의 요청에 대해 간섭받지 않게 구현해야 합니다. <br>

### 발생 할 수 있는 동시성 문제
- 포인트와 같은 금전적 트랜잭션을 처리할 때,
동일한 사용자에 대한 여러 요청이 동시에 들어오면 일관성이 없는 상태가 발생할 수 있습니다. 
예를 들어, 두 스레드가 동시에 포인트를 충전하거나 사용하면, 최종 포인트 잔액이 올바르게 계산되지 않을 수 있습니다.

### 해결 방법: 사용자별 고유 락 사용
- 동시성 문제를 해결하기 위해 ConcurrentHashMap<Long, ReentrantLock>을 사용하여 사용자별로 고유한 락을 생성하고 관리합니다. 
이 ReentrantLock은 특정 사용자에 대한 요청이 순차적으로 처리되도록 보장하여 최종 포인트 잔액이 올바르게 계산 됩니다.

- UserLockManager: 사용자의 락을 관리하는 유틸리티 클래스입니다. 
특정 사용자의 요청이 들어오면 그 사용자에 대해 고유한 락을 할당하고, 요청이 끝나면 락을 해제합니다.
withLock 메서드를 사용하여 락을 간편하게 사용할 수 있고, 락 해제는 메서드가 예외를 던져도 자동으로 처리됩니다.

### 구현 세부 사항
- savePoint 및 usePoint 메서드는 withLock 블록 안에서 실행되어, 같은 사용자에 대한 여러 요청이 독립적으로 처리되도록 보장합니다.
테스트에서는 Executors.newFixedThreadPool()과 CompletableFuture를 사용하여 
동시에 여러 스레드가 동일한 사용자에 대해 요청을 처리하는 상황을 시뮬레이션했습니다.

### 동시성 테스트
- 두 개의 스레드가 동시에 한 사용자의 포인트를 충전하거나 사용하는 시나리오를 테스트하여, 요청이 독립적으로 처리되는지 확인했습니다.
먼저 사용자의 계정에 초기 포인트를 충전합니다. 두 개의 스레드를 생성하여 하나는 포인트를 충전하고, 다른 하나는 포인트를 사용하는 요청을 보냅니다.
최종 포인트 잔액과 트랜잭션 히스토리를 확인하여 요청이 올바르게 처리되었는지 검증합니다.